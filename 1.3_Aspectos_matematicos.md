# 1.3 Aspectos matemáticos de la graficación

Cualquier píxel dibujado en pantalla requiere operaciones numéricas por debajo. El diseño de modelos gráficos exige el uso intensivo de herramientas matemáticas robustas para solucionar problemas de trazo, posición, deformación y física:

- **Álgebra Lineal:** El uso de matrices y vectores es indispensable para representar coordenadas de puntos y ejecutar transformaciones afines fundamentales en el espacio 2D y 3D (Traslación, Rotación, Escalamiento).
- **Geometría Analítica:** Permite delimitar espacios utilizando ecuaciones de la recta para el _clipping_ (recortes de visión) y la definición de las fronteras de polígonos irregulares y regulares (Círculos, Hexágonos, etc).
- **Cálculo y Curvas:** Vital para los gráficos vectoriales complejos, utilizando curvas paramétricas de Bezier, B-Splines o NURBS (Non-Uniform Rational B-Splines). Éstas garantizan superficies infinitamente suaves evaluando derivadas continuas, lo cual es inalcanzable usando simples y toscos polígonos triangulares (Farin, 2001).
- **Trigonometría y Quaterniones:** Mientras que el álgebra lineal de Euler sirve para la rotación 3D, sufre de _Gimbal Lock_ (Pérdida de un grado de libertad al rotar). Para solucionar esto en videojuegos y animación avanzada, las rotaciones de cámara y cinemática inversa de esqueletos (Rigging) se calculan mediante **Quaterniones**, un sistema de números hipercomplejos que interpolan esféricamente el movimiento (Shoemake, 1985).

### Ejemplo de Código: Álgebra para Traslación Afín
Todas las operaciones de la graficación, cuando mueves un mouse o una figura, consisten en multiplicar una matriz base. Con `NumPy` podemos simular lo que hace la GPU al trasladar un polígono en un plano 2D:

```python
import numpy as np

# Punto original (x, y) en el plano y adición de valor homogéneo (1)
punto_original = np.array([5, 3, 1])

# Matriz de Traslación M (Mover 10 unidades en X, y -2 unidades en Y)
tx, ty = 10, -2
matriz_traslacion = np.array([
    [1, 0, tx],
    [0, 1, ty],
    [0, 0, 1]
])

# Operación central de la graficación (Multiplicación de matrices)
punto_nuevo = np.dot(matriz_traslacion, punto_original)

print(f"Coordenada Inicial: {punto_original[:2]}")
print(f"Coordenada Final tras la matriz: {punto_nuevo[:2]}")
# Resultado esperado [15, 1]
```

---

## Referencias Documentales

Anton, H., & Rorres, C. (2013). _Elementary Linear Algebra: Applications Version_ (11a ed.). Wiley. 

Farin, G. (2001). _Curves and Surfaces for CAGD: A Practical Guide_ (5a ed.). Morgan Kaufmann. https://doi.org/10.1016/B978-1-55860-737-8.X5000-0

Shoemake, K. (1985). Animating rotation with quaternion curves. _ACM SIGGRAPH Computer Graphics_, 19(3), 245-254. https://doi.org/10.1145/325165.325242
