# 1.5 Representación y trazo de líneas y polígonos

Nos referimos a la algoritmia matemática de más bajo nivel en la computación gráfica: **La Rasterización**. Son los métodos discretos que determinan la secuencia lógica en la que ciertos píxeles deben encenderse, y con qué proporción cromática, para trazar ilusiones de figuras geométricas vectoriales continuas en una retícula física (pantalla) formada por pixeles diminutos (Shirley et al., 2009).

Este proceso de aproximación matemática desde curvas ideales hacia celdas cuadradas genera el conocido artefacto visual de **_Aliasing_** (bordes dentados en forma de escalera). Históricamente, el desafío técnico consistía en programar sub-rutinas rápidas usando enteros en lugar de costosos números flotantes. El _Algoritmo DDA (Digital Differential Analyzer)_ y el famoso _Algoritmo de Línea de Bresenham_ (1965) son las piedras angulares de estos cálculos primitivos, prediciendo qué pixel contiguo aproxima mejor a la recta de origen.

### 1.5.1 Formatos de imagen
Las escenas generadas pueden grabarse para la posteridad de diferentes maneras:
- **Mapas de bits (Raster / Rastreo):** Son imágenes almacenadas puramente como un gran arreglo 2D de píxeles estáticos (Matrices de Color); ej. PNG, JPG o BMP. Al aplicar _Zoom_, su limitada resolución de matriz revela los bloques individuales perdiendo el contorno.
- **Vectoriales:** Formatos como el famosísimo SVG. No almacenan píxeles fijos, sino que **instrucciones geométricas y fórmulas analíticas puras** de nodos e intersecciones escalables. El motor recalcula la rasterización en tiempo real dependiendo de la pantalla, garantizando resolución matemáticamente perfecta independientemente de la ampliación (Hearn et al., 2014).

### Ejercicios Prácticos de Dibujo de Polígonos y Curvas (con API Python de Blender)

A continuación, mostramos la teoría convertida en automatización.

#### Práctica 1: Dibujo de un Polígono y Álgebra Polar
Se usa la trigonometría (Seno y Coseno) en la programación para trazar las aristas de un polígono perfecto en Blender (ej. hexágono).

```python
import bpy, math

# Paso 1: Limpieza
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete()

# Paso 2 y 3: Configuración de Geometría
lados = 6  # Hexágono de 6 caras
radio = 5
vertices = []
aristas = []

# Trigonometría de Ángulos Espaciales 
for i in range(lados):
    angulo = 2 * math.pi * i / lados # Conversión de fracciones del círculo completo 
    x = radio * math.cos(angulo)     # Coordenada en X
    y = radio * math.sin(angulo)     # Coordenada en Y
    vertices.append((x, y, 0))

# Cerrar el contorno
for i in range(lados):
    aristas.append((i, (i + 1) % lados))

# Paso 4: Inyección a la malla en Escena
malla = bpy.data.meshes.new("Poligono2D")
objeto = bpy.data.objects.new("Poligono2D", malla)
bpy.context.collection.objects.link(objeto)

malla.from_pydata(vertices, aristas, [])
malla.update()
```

#### Práctica 2: La Flor de la Vida 
Esta composición geométrica demuestra cómo aplicar conceptos de **Traslación** y **Rotación**, utilizando círculos superpuestos controlados por un bucle lógico de acumulación de grados polares:

```python
import bpy, math

# Limpiar Escena predefinida de Blender
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete()

# Variables y Condiciones Limites
radio = 3
angulo_actual = 0
paso_angular = 60 # Cada iteración avanzará una fracción sexagesimal para orbitar

# 1er Elemento: Círculo Primitivo Central (Origen)
bpy.ops.mesh.primitive_circle_add(radius=radio, location=(0, 0, 0), vertices=64)

# Rotación Procedural vía Bucle de Ciclo "Mientras"
while angulo_actual < 360:
    # Conversión Polar a Cartesiano
    x = radio * math.cos(math.radians(angulo_actual))
    y = radio * math.sin(math.radians(angulo_actual))
    
    # 2do Elemento: Lluvia de Círculos "Pétalo" en los vértices del radio del primero
    bpy.ops.mesh.primitive_circle_add(radius=radio, location=(x, y, 0), vertices=64)
    
    # Fundamental: Acumulador (Impedir Bucle Infinito del "While")
    angulo_actual += paso_angular
```

---

## Referencias Documentales

Bresenham, J. E. (1965). Algorithm for computer control of a digital plotter. _IBM Systems journal_, 4(1), 25-30. https://doi.org/10.1147/sj.41.0025

Hearn, D., Baker, M. P., & Carithers, W. R. (2014). _Computer Graphics with Open GL_ (4a ed.). Pearson.

Shirley, P., Ashikhmin, M., & Marschner, S. (2009). _Fundamentals of Computer Graphics_ (3a ed.). A K Peters/CRC Press.
