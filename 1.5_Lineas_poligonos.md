# 1.5 Representación y trazo de líneas y polígonos

Nos referimos a la algoritmia base de computador. Son los métodos que determinan el orden lógico en que ciertos píxeles deben encenderse y con qué proporción cromática para trazar ilusiones de figuras geométricas en una retícula formada por pixeles diminutos, superando en ocasiones el fenómeno informático de _Aliasing_ (bordes dentados).

### 1.5.1 Formatos de imagen
Dichas representaciones pueden grabarse para postestad de diferentes maneras:
- **Mapas de bits (Raster / Rastreo):** Son imágenes almacenadas por coordenadas como un gran arreglo de matrices de color por cada bloque o pixel; ej. PNG, JPG o BMP. Al buscar ver un detalle, muestran cuadrados pixelados perdiendo la definición original.
- **Vectoriales:** Formatos como el famosísimo SVG. No guardan posiciones, guardan comandos y fórmulas matemáticas puras de nodos e intersecciones escalables; puedes imprimirlo del tamaño de un estadio sin pérdida mínima de calidad y contornos perfectos.

### Ejercicios Prácticos de Dibujo de Polígonos y Curvas (con API Python de Blender)

A continuación, mostramos la teoría convertida en automatización.

#### Práctica 1: Dibujo de un Polígono y Álgebra Polar
Se usa la trigonometría (Seno y Coseno) en la programación para trazar las aristas de un polígono perfecto en Blender (ej. hexágono).

```python
import bpy, math

# Paso 1: Limpieza
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete()

# Paso 2 y 3: Configuración de Geometría
lados = 6  # Hexágono de 6 caras
radio = 5
vertices = []
aristas = []

# Trigonometría de Ángulos Espaciales 
for i in range(lados):
    angulo = 2 * math.pi * i / lados # Conversión de fracciones del círculo completo 
    x = radio * math.cos(angulo)     # Coordenada en X
    y = radio * math.sin(angulo)     # Coordenada en Y
    vertices.append((x, y, 0))

# Cerrar el contorno
for i in range(lados):
    aristas.append((i, (i + 1) % lados))

# Paso 4: Inyección a la malla en Escena
malla = bpy.data.meshes.new("Poligono2D")
objeto = bpy.data.objects.new("Poligono2D", malla)
bpy.context.collection.objects.link(objeto)

malla.from_pydata(vertices, aristas, [])
malla.update()
```

#### Práctica 2: La Flor de la Vida 
Esta composición geométrica demuestra cómo aplicar conceptos de **Traslación** y **Rotación**, utilizando círculos superpuestos controlados por un bucle lógico de acumulación de grados polares:

```python
import bpy, math

# Limpiar Escena predefinida de Blender
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete()

# Variables y Condiciones Limites
radio = 3
angulo_actual = 0
paso_angular = 60 # Cada iteración avanzará una fracción sexagesimal para orbitar

# 1er Elemento: Círculo Primitivo Central (Origen)
bpy.ops.mesh.primitive_circle_add(radius=radio, location=(0, 0, 0), vertices=64)

# Rotación Procedural vía Bucle de Ciclo "Mientras"
while angulo_actual < 360:
    # Conversión Polar a Cartesiano
    x = radio * math.cos(math.radians(angulo_actual))
    y = radio * math.sin(math.radians(angulo_actual))
    
    # 2do Elemento: Lluvia de Círculos "Pétalo" en los vértices del radio del primero
    bpy.ops.mesh.primitive_circle_add(radius=radio, location=(x, y, 0), vertices=64)
    
    # Fundamental: Acumulador (Impedir Bucle Infinito del "While")
    angulo_actual += paso_angular
```

---

## Referencias
*   Foley, J. D., & Van Dam, A. (1982). _Fundamentals of Interactive Computer Graphics_. Addison-Wesley.
*   Documentación de la API Pyside de Blender 3D: https://docs.blender.org/api/current/bpy.ops.mesh.html
